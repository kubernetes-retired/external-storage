package filesystem

// Copyright (c) Microsoft and contributors.  All rights reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
//
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by Microsoft (R) AutoRest Code Generator 0.17.0.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

import (
	"github.com/Azure/go-autorest/autorest"
	"github.com/Azure/go-autorest/autorest/azure"
	"github.com/Azure/go-autorest/autorest/validation"
	"io"
	"net/http"
)

// Client is the creates an Azure Data Lake Store filesystem client.
type Client struct {
	ManagementClient
}

// NewClient creates an instance of the Client client.
func NewClient(adlsFileSystemDNSSuffix string) Client {
	return NewClientWithBaseURI(DefaultBaseURI, adlsFileSystemDNSSuffix)
}

// NewClientWithBaseURI creates an instance of the Client client.
func NewClientWithBaseURI(baseURI string, adlsFileSystemDNSSuffix string) Client {
	return Client{NewWithBaseURI(baseURI, adlsFileSystemDNSSuffix)}
}

// Append appends to the specified file. This method does not support multiple
// concurrent appends to the file. NOTE: Concurrent append and normal
// (serial) append CANNOT be used interchangeably. Once a file has been
// appended to using either append option, it can only be appended to using
// that append option. Use the ConcurrentAppend option if you would like
// support for concurrent appends.
//
// directFilePath is the Data Lake Store path (starting with '/') of the file
// to which to append. streamContents is the file contents to include when
// appending to the file. streamContents will be closed upon successful
// return. Callers should ensure closure when receiving an error.op is the
// constant value for the operation. appendParameter is the constant value
// for the operation. offset is the optional offset in the stream to begin
// the append operation. Default is to append at the end of the stream.
// syncFlag is optionally indicates what to do after completion of the
// append. DATA indicates more data is coming so no sync takes place,
// METADATA indicates a sync should be done to refresh metadata of the file
// only. CLOSE indicates that both the stream and metadata should be
// refreshed upon append completion. Possible values include: 'DATA',
// 'METADATA', 'CLOSE'
func (client Client) Append(directFilePath string, streamContents io.ReadCloser, op string, appendParameter string, offset *int64, syncFlag SyncFlag) (result autorest.Response, err error) {
	req, err := client.AppendPreparer(directFilePath, streamContents, op, appendParameter, offset, syncFlag)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Append", nil, "Failure preparing request")
	}

	resp, err := client.AppendSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Append", resp, "Failure sending request")
	}

	result, err = client.AppendResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "Append", resp, "Failure responding to request")
	}

	return
}

// AppendPreparer prepares the Append request.
func (client Client) AppendPreparer(directFilePath string, streamContents io.ReadCloser, op string, appendParameter string, offset *int64, syncFlag SyncFlag) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"directFilePath": autorest.Encode("path", directFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"append":      autorest.Encode("query", appendParameter),
		"op":          autorest.Encode("query", op),
	}
	if offset != nil {
		queryParameters["offset"] = autorest.Encode("query", *offset)
	}
	if len(string(syncFlag)) > 0 {
		queryParameters["syncFlag"] = autorest.Encode("query", syncFlag)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{directFilePath}", pathParameters),
		autorest.WithFile(streamContents),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// AppendSender sends the Append request. The method will close the
// http.Response Body if it receives an error.
func (client Client) AppendSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// AppendResponder handles the response to the Append request. The method always
// closes the http.Response Body.
func (client Client) AppendResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// CheckAccess checks if the specified access is available at the given path.
//
// pathParameter is the Data Lake Store path (starting with '/') of the file
// or directory for which to check access. op is the constant value for the
// operation. fsaction is file system operation read/write/execute in string
// form, matching regex pattern '[rwx-]{3}'
func (client Client) CheckAccess(pathParameter string, op string, fsaction string) (result autorest.Response, err error) {
	req, err := client.CheckAccessPreparer(pathParameter, op, fsaction)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "CheckAccess", nil, "Failure preparing request")
	}

	resp, err := client.CheckAccessSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "CheckAccess", resp, "Failure sending request")
	}

	result, err = client.CheckAccessResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "CheckAccess", resp, "Failure responding to request")
	}

	return
}

// CheckAccessPreparer prepares the CheckAccess request.
func (client Client) CheckAccessPreparer(pathParameter string, op string, fsaction string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"path": autorest.Encode("path", pathParameter),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if len(fsaction) > 0 {
		queryParameters["fsaction"] = autorest.Encode("query", fsaction)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{path}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// CheckAccessSender sends the CheckAccess request. The method will close the
// http.Response Body if it receives an error.
func (client Client) CheckAccessSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// CheckAccessResponder handles the response to the CheckAccess request. The method always
// closes the http.Response Body.
func (client Client) CheckAccessResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Concat concatenates the list of source files into the destination file,
// removing all source files upon success.
//
// destinationPath is the Data Lake Store path (starting with '/') of the
// destination file resulting from the concatenation. sources is a list of
// comma seperated Data Lake Store paths (starting with '/') of the files to
// concatenate, in the order in which they should be concatenated. op is the
// constant value for the operation.
func (client Client) Concat(destinationPath string, sources []string, op string) (result autorest.Response, err error) {
	if err := validation.Validate([]validation.Validation{
		{TargetValue: sources,
			Constraints: []validation.Constraint{{Target: "sources", Name: validation.Null, Rule: true, Chain: nil}}}}); err != nil {
		return result, validation.NewErrorWithValidationError(err, "filesystem.Client", "Concat")
	}

	req, err := client.ConcatPreparer(destinationPath, sources, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Concat", nil, "Failure preparing request")
	}

	resp, err := client.ConcatSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Concat", resp, "Failure sending request")
	}

	result, err = client.ConcatResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "Concat", resp, "Failure responding to request")
	}

	return
}

// ConcatPreparer prepares the Concat request.
func (client Client) ConcatPreparer(destinationPath string, sources []string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"destinationPath": autorest.Encode("path", destinationPath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
		"sources":     autorest.Encode("query", sources, ","),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{destinationPath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ConcatSender sends the Concat request. The method will close the
// http.Response Body if it receives an error.
func (client Client) ConcatSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ConcatResponder handles the response to the Concat request. The method always
// closes the http.Response Body.
func (client Client) ConcatResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// ConcurrentAppend appends to the specified file. This method supports
// multiple concurrent appends to the file. NOTE: ConcurrentAppend and normal
// (serial) Append CANNOT be used interchangeably; once a file has been
// appended to using either of these append options, it can only be appended
// to using that append option. ConcurrentAppend DOES NOT guarantee order and
// can result in duplicated data landing in the target file.
//
// filePath is the Data Lake Store path (starting with '/') of the file to
// which to append using concurrent append. streamContents is the file
// contents to include when appending to the file. streamContents will be
// closed upon successful return. Callers should ensure closure when
// receiving an error.op is the constant value for the operation.
// transferEncoding is indicates the data being sent to the server is being
// streamed in chunks. appendMode is indicates the concurrent append call
// should create the file if it doesn't exist or just open the existing file
// for append. Possible values include: 'autocreate'
func (client Client) ConcurrentAppend(filePath string, streamContents io.ReadCloser, op string, transferEncoding string, appendMode AppendModeType) (result autorest.Response, err error) {
	req, err := client.ConcurrentAppendPreparer(filePath, streamContents, op, transferEncoding, appendMode)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "ConcurrentAppend", nil, "Failure preparing request")
	}

	resp, err := client.ConcurrentAppendSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "ConcurrentAppend", resp, "Failure sending request")
	}

	result, err = client.ConcurrentAppendResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "ConcurrentAppend", resp, "Failure responding to request")
	}

	return
}

// ConcurrentAppendPreparer prepares the ConcurrentAppend request.
func (client Client) ConcurrentAppendPreparer(filePath string, streamContents io.ReadCloser, op string, transferEncoding string, appendMode AppendModeType) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"filePath": autorest.Encode("path", filePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if len(string(appendMode)) > 0 {
		queryParameters["appendMode"] = autorest.Encode("query", appendMode)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/WebHdfsExt/{filePath}", pathParameters),
		autorest.WithFile(streamContents),
		autorest.WithQueryParameters(queryParameters),
		autorest.WithHeader("Transfer-Encoding", autorest.String(transferEncoding)))
	return preparer.Prepare(&http.Request{})
}

// ConcurrentAppendSender sends the ConcurrentAppend request. The method will close the
// http.Response Body if it receives an error.
func (client Client) ConcurrentAppendSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ConcurrentAppendResponder handles the response to the ConcurrentAppend request. The method always
// closes the http.Response Body.
func (client Client) ConcurrentAppendResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Create creates a file with optionally specified content.
//
// directFilePath is the Data Lake Store path (starting with '/') of the file
// to create. op is the constant value for the operation. write is the
// constant value for the operation. streamContents is the file contents to
// include when creating the file. This parameter is optional, resulting in
// an empty file if not specified. streamContents will be closed upon
// successful return. Callers should ensure closure when receiving an
// error.overwrite is the indication of if the file should be overwritten.
// syncFlag is optionally indicates what to do after completion of the
// append. DATA indicates more data is coming so no sync takes place,
// METADATA indicates a sync should be done to refresh metadata of the file
// only. CLOSE indicates that both the stream and metadata should be
// refreshed upon append completion. Possible values include: 'DATA',
// 'METADATA', 'CLOSE'
func (client Client) Create(directFilePath string, op string, write string, streamContents io.ReadCloser, overwrite *bool, syncFlag SyncFlag) (result autorest.Response, err error) {
	req, err := client.CreatePreparer(directFilePath, op, write, streamContents, overwrite, syncFlag)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Create", nil, "Failure preparing request")
	}

	resp, err := client.CreateSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Create", resp, "Failure sending request")
	}

	result, err = client.CreateResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "Create", resp, "Failure responding to request")
	}

	return
}

// CreatePreparer prepares the Create request.
func (client Client) CreatePreparer(directFilePath string, op string, write string, streamContents io.ReadCloser, overwrite *bool, syncFlag SyncFlag) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"directFilePath": autorest.Encode("path", directFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
		"write":       autorest.Encode("query", write),
	}
	if overwrite != nil {
		queryParameters["overwrite"] = autorest.Encode("query", *overwrite)
	}
	if len(string(syncFlag)) > 0 {
		queryParameters["syncFlag"] = autorest.Encode("query", syncFlag)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{directFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	if streamContents != nil {
		preparer = autorest.DecoratePreparer(preparer,
			autorest.WithJSON(streamContents))
	}
	return preparer.Prepare(&http.Request{})
}

// CreateSender sends the Create request. The method will close the
// http.Response Body if it receives an error.
func (client Client) CreateSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// CreateResponder handles the response to the Create request. The method always
// closes the http.Response Body.
func (client Client) CreateResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK, http.StatusCreated),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Delete deletes the requested file or directory, optionally recursively.
//
// filePath is the Data Lake Store path (starting with '/') of the file or
// directory to delete. op is the constant value for the operation. recursive
// is the optional switch indicating if the delete should be recursive
func (client Client) Delete(filePath string, op string, recursive *bool) (result FileOperationResult, err error) {
	req, err := client.DeletePreparer(filePath, op, recursive)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Delete", nil, "Failure preparing request")
	}

	resp, err := client.DeleteSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Delete", resp, "Failure sending request")
	}

	result, err = client.DeleteResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "Delete", resp, "Failure responding to request")
	}

	return
}

// DeletePreparer prepares the Delete request.
func (client Client) DeletePreparer(filePath string, op string, recursive *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"filePath": autorest.Encode("path", filePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if recursive != nil {
		queryParameters["recursive"] = autorest.Encode("query", *recursive)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsDelete(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{filePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// DeleteSender sends the Delete request. The method will close the
// http.Response Body if it receives an error.
func (client Client) DeleteSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// DeleteResponder handles the response to the Delete request. The method always
// closes the http.Response Body.
func (client Client) DeleteResponder(resp *http.Response) (result FileOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetACLStatus gets Access Control List (ACL) entries for the specified file
// or directory.
//
// aclFilePath is the Data Lake Store path (starting with '/') of the file or
// directory for which to get the ACL. op is the constant value for the
// operation.
func (client Client) GetACLStatus(aclFilePath string, op string) (result ACLStatusResult, err error) {
	req, err := client.GetACLStatusPreparer(aclFilePath, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "GetACLStatus", nil, "Failure preparing request")
	}

	resp, err := client.GetACLStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "GetACLStatus", resp, "Failure sending request")
	}

	result, err = client.GetACLStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "GetACLStatus", resp, "Failure responding to request")
	}

	return
}

// GetACLStatusPreparer prepares the GetACLStatus request.
func (client Client) GetACLStatusPreparer(aclFilePath string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"aclFilePath": autorest.Encode("path", aclFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{aclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetACLStatusSender sends the GetACLStatus request. The method will close the
// http.Response Body if it receives an error.
func (client Client) GetACLStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetACLStatusResponder handles the response to the GetACLStatus request. The method always
// closes the http.Response Body.
func (client Client) GetACLStatusResponder(resp *http.Response) (result ACLStatusResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetContentSummary gets the file content summary object specified by the
// file path.
//
// getContentSummaryFilePath is the Data Lake Store path (starting with '/')
// of the file for which to retrieve the summary. op is the constant value
// for the operation.
func (client Client) GetContentSummary(getContentSummaryFilePath string, op string) (result ContentSummaryResult, err error) {
	req, err := client.GetContentSummaryPreparer(getContentSummaryFilePath, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "GetContentSummary", nil, "Failure preparing request")
	}

	resp, err := client.GetContentSummarySender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "GetContentSummary", resp, "Failure sending request")
	}

	result, err = client.GetContentSummaryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "GetContentSummary", resp, "Failure responding to request")
	}

	return
}

// GetContentSummaryPreparer prepares the GetContentSummary request.
func (client Client) GetContentSummaryPreparer(getContentSummaryFilePath string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"getContentSummaryFilePath": autorest.Encode("path", getContentSummaryFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/va/{getContentSummaryFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetContentSummarySender sends the GetContentSummary request. The method will close the
// http.Response Body if it receives an error.
func (client Client) GetContentSummarySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetContentSummaryResponder handles the response to the GetContentSummary request. The method always
// closes the http.Response Body.
func (client Client) GetContentSummaryResponder(resp *http.Response) (result ContentSummaryResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// GetFileStatus get the file status object specified by the file path.
//
// getFilePath is the Data Lake Store path (starting with '/') of the file or
// directory for which to retrieve the status. op is the constant value for
// the operation.
func (client Client) GetFileStatus(getFilePath string, op string) (result FileStatusResult, err error) {
	req, err := client.GetFileStatusPreparer(getFilePath, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "GetFileStatus", nil, "Failure preparing request")
	}

	resp, err := client.GetFileStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "GetFileStatus", resp, "Failure sending request")
	}

	result, err = client.GetFileStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "GetFileStatus", resp, "Failure responding to request")
	}

	return
}

// GetFileStatusPreparer prepares the GetFileStatus request.
func (client Client) GetFileStatusPreparer(getFilePath string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"getFilePath": autorest.Encode("path", getFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{getFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// GetFileStatusSender sends the GetFileStatus request. The method will close the
// http.Response Body if it receives an error.
func (client Client) GetFileStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// GetFileStatusResponder handles the response to the GetFileStatus request. The method always
// closes the http.Response Body.
func (client Client) GetFileStatusResponder(resp *http.Response) (result FileStatusResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ListFileStatus get the list of file status objects specified by the file
// path, with optional pagination parameters
//
// listFilePath is the Data Lake Store path (starting with '/') of the
// directory to list. op is the constant value for the operation. listSize is
// gets or sets the number of items to return. Optional. listAfter is gets or
// sets the item or lexographical index after which to begin returning
// results. For example, a file list of 'a','b','d' and listAfter='b' will
// return 'd', and a listAfter='c' will also return 'd'. Optional. listBefore
// is gets or sets the item or lexographical index before which to begin
// returning results. For example, a file list of 'a','b','d' and
// listBefore='d' will return 'a','b', and a listBefore='c' will also return
// 'a','b'. Optional.
func (client Client) ListFileStatus(listFilePath string, op string, listSize *int32, listAfter string, listBefore string) (result FileStatusesResult, err error) {
	req, err := client.ListFileStatusPreparer(listFilePath, op, listSize, listAfter, listBefore)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "ListFileStatus", nil, "Failure preparing request")
	}

	resp, err := client.ListFileStatusSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "ListFileStatus", resp, "Failure sending request")
	}

	result, err = client.ListFileStatusResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "ListFileStatus", resp, "Failure responding to request")
	}

	return
}

// ListFileStatusPreparer prepares the ListFileStatus request.
func (client Client) ListFileStatusPreparer(listFilePath string, op string, listSize *int32, listAfter string, listBefore string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"listFilePath": autorest.Encode("path", listFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if listSize != nil {
		queryParameters["listSize"] = autorest.Encode("query", *listSize)
	}
	if len(listAfter) > 0 {
		queryParameters["listAfter"] = autorest.Encode("query", listAfter)
	}
	if len(listBefore) > 0 {
		queryParameters["listBefore"] = autorest.Encode("query", listBefore)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{listFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ListFileStatusSender sends the ListFileStatus request. The method will close the
// http.Response Body if it receives an error.
func (client Client) ListFileStatusSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ListFileStatusResponder handles the response to the ListFileStatus request. The method always
// closes the http.Response Body.
func (client Client) ListFileStatusResponder(resp *http.Response) (result FileStatusesResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// Mkdirs creates a directory.
//
// pathParameter is the Data Lake Store path (starting with '/') of the
// directory to create. op is the constant value for the operation.
func (client Client) Mkdirs(pathParameter string, op string) (result FileOperationResult, err error) {
	req, err := client.MkdirsPreparer(pathParameter, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Mkdirs", nil, "Failure preparing request")
	}

	resp, err := client.MkdirsSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Mkdirs", resp, "Failure sending request")
	}

	result, err = client.MkdirsResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "Mkdirs", resp, "Failure responding to request")
	}

	return
}

// MkdirsPreparer prepares the Mkdirs request.
func (client Client) MkdirsPreparer(pathParameter string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"path": autorest.Encode("path", pathParameter),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{path}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// MkdirsSender sends the Mkdirs request. The method will close the
// http.Response Body if it receives an error.
func (client Client) MkdirsSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// MkdirsResponder handles the response to the Mkdirs request. The method always
// closes the http.Response Body.
func (client Client) MkdirsResponder(resp *http.Response) (result FileOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// ModifyACLEntries modifies existing Access Control List (ACL) entries on a
// file or folder.
//
// modifyACLFilePath is the Data Lake Store path (starting with '/') of the
// file or directory with the ACL being modified. aclspec is the ACL
// specification included in ACL modification operations in the format
// '[default:]user|group|other::r|-w|-x|-' op is the constant value for the
// operation.
func (client Client) ModifyACLEntries(modifyACLFilePath string, aclspec string, op string) (result autorest.Response, err error) {
	req, err := client.ModifyACLEntriesPreparer(modifyACLFilePath, aclspec, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "ModifyACLEntries", nil, "Failure preparing request")
	}

	resp, err := client.ModifyACLEntriesSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "ModifyACLEntries", resp, "Failure sending request")
	}

	result, err = client.ModifyACLEntriesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "ModifyACLEntries", resp, "Failure responding to request")
	}

	return
}

// ModifyACLEntriesPreparer prepares the ModifyACLEntries request.
func (client Client) ModifyACLEntriesPreparer(modifyACLFilePath string, aclspec string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"modifyAclFilePath": autorest.Encode("path", modifyACLFilePath),
	}

	queryParameters := map[string]interface{}{
		"aclspec":     autorest.Encode("query", aclspec),
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{modifyAclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// ModifyACLEntriesSender sends the ModifyACLEntries request. The method will close the
// http.Response Body if it receives an error.
func (client Client) ModifyACLEntriesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// ModifyACLEntriesResponder handles the response to the ModifyACLEntries request. The method always
// closes the http.Response Body.
func (client Client) ModifyACLEntriesResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// MsConcat concatenates the list of source files into the destination file,
// deleting all source files upon success. This method accepts more source
// file paths than the Concat method. This method and the parameters it
// accepts are subject to change for usability in an upcoming version.
//
// msConcatDestinationPath is the Data Lake Store path (starting with '/') of
// the destination file resulting from the concatenation. streamContents is a
// list of Data Lake Store paths (starting with '/') of the source files.
// Must be in the format: sources=<comma separated list> streamContents will
// be closed upon successful return. Callers should ensure closure when
// receiving an error.op is the constant value for the operation.
// deleteSourceDirectory is indicates that as an optimization instead of
// deleting each individual source stream, delete the source stream folder if
// all streams are in the same folder instead. This results in a substantial
// performance improvement when the only streams in the folder are part of
// the concatenation operation. WARNING: This includes the deletion of any
// other files that are not source files. Only set this to true when source
// files are the only files in the source directory.
func (client Client) MsConcat(msConcatDestinationPath string, streamContents io.ReadCloser, op string, deleteSourceDirectory *bool) (result autorest.Response, err error) {
	req, err := client.MsConcatPreparer(msConcatDestinationPath, streamContents, op, deleteSourceDirectory)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "MsConcat", nil, "Failure preparing request")
	}

	resp, err := client.MsConcatSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "MsConcat", resp, "Failure sending request")
	}

	result, err = client.MsConcatResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "MsConcat", resp, "Failure responding to request")
	}

	return
}

// MsConcatPreparer prepares the MsConcat request.
func (client Client) MsConcatPreparer(msConcatDestinationPath string, streamContents io.ReadCloser, op string, deleteSourceDirectory *bool) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"msConcatDestinationPath": autorest.Encode("path", msConcatDestinationPath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if deleteSourceDirectory != nil {
		queryParameters["deleteSourceDirectory"] = autorest.Encode("query", *deleteSourceDirectory)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPost(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{msConcatDestinationPath}", pathParameters),
		autorest.WithFile(streamContents),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// MsConcatSender sends the MsConcat request. The method will close the
// http.Response Body if it receives an error.
func (client Client) MsConcatSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// MsConcatResponder handles the response to the MsConcat request. The method always
// closes the http.Response Body.
func (client Client) MsConcatResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Open opens and reads from the specified file.
//
// directFilePath is the Data Lake Store path (starting with '/') of the file
// to open. op is the constant value for the operation. read is the constant
// value for the operation. length is the number of bytes that the server
// will attempt to retrieve. It will retrieve <= length bytes. offset is the
// byte offset to start reading data from.
func (client Client) Open(directFilePath string, op string, read string, length *int64, offset *int64) (result ReadCloser, err error) {
	req, err := client.OpenPreparer(directFilePath, op, read, length, offset)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Open", nil, "Failure preparing request")
	}

	resp, err := client.OpenSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Open", resp, "Failure sending request")
	}

	result, err = client.OpenResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "Open", resp, "Failure responding to request")
	}

	return
}

// OpenPreparer prepares the Open request.
func (client Client) OpenPreparer(directFilePath string, op string, read string, length *int64, offset *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"directFilePath": autorest.Encode("path", directFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
		"read":        autorest.Encode("query", read),
	}
	if length != nil {
		queryParameters["length"] = autorest.Encode("query", *length)
	}
	if offset != nil {
		queryParameters["offset"] = autorest.Encode("query", *offset)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsGet(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{directFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// OpenSender sends the Open request. The method will close the
// http.Response Body if it receives an error.
func (client Client) OpenSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// OpenResponder handles the response to the Open request. The method always
// closes the http.Response Body.
func (client Client) OpenResponder(resp *http.Response) (result ReadCloser, err error) {
	result.Value = &resp.Body
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK))
	result.Response = autorest.Response{Response: resp}
	return
}

// RemoveACL removes the existing Access Control List (ACL) of the specified
// file or directory.
//
// aclFilePath is the Data Lake Store path (starting with '/') of the file or
// directory with the ACL being removed. op is the constant value for the
// operation.
func (client Client) RemoveACL(aclFilePath string, op string) (result autorest.Response, err error) {
	req, err := client.RemoveACLPreparer(aclFilePath, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "RemoveACL", nil, "Failure preparing request")
	}

	resp, err := client.RemoveACLSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "RemoveACL", resp, "Failure sending request")
	}

	result, err = client.RemoveACLResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "RemoveACL", resp, "Failure responding to request")
	}

	return
}

// RemoveACLPreparer prepares the RemoveACL request.
func (client Client) RemoveACLPreparer(aclFilePath string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"aclFilePath": autorest.Encode("path", aclFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{aclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// RemoveACLSender sends the RemoveACL request. The method will close the
// http.Response Body if it receives an error.
func (client Client) RemoveACLSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// RemoveACLResponder handles the response to the RemoveACL request. The method always
// closes the http.Response Body.
func (client Client) RemoveACLResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RemoveACLEntries removes existing Access Control List (ACL) entries for a
// file or folder.
//
// removeACLFilePath is the Data Lake Store path (starting with '/') of the
// file or directory with the ACL being removed. aclspec is the ACL spec
// included in ACL removal operations in the format
// '[default:]user|group|other' op is the constant value for the operation.
func (client Client) RemoveACLEntries(removeACLFilePath string, aclspec string, op string) (result autorest.Response, err error) {
	req, err := client.RemoveACLEntriesPreparer(removeACLFilePath, aclspec, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "RemoveACLEntries", nil, "Failure preparing request")
	}

	resp, err := client.RemoveACLEntriesSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "RemoveACLEntries", resp, "Failure sending request")
	}

	result, err = client.RemoveACLEntriesResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "RemoveACLEntries", resp, "Failure responding to request")
	}

	return
}

// RemoveACLEntriesPreparer prepares the RemoveACLEntries request.
func (client Client) RemoveACLEntriesPreparer(removeACLFilePath string, aclspec string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"removeAclFilePath": autorest.Encode("path", removeACLFilePath),
	}

	queryParameters := map[string]interface{}{
		"aclspec":     autorest.Encode("query", aclspec),
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{removeAclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// RemoveACLEntriesSender sends the RemoveACLEntries request. The method will close the
// http.Response Body if it receives an error.
func (client Client) RemoveACLEntriesSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// RemoveACLEntriesResponder handles the response to the RemoveACLEntries request. The method always
// closes the http.Response Body.
func (client Client) RemoveACLEntriesResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// RemoveDefaultACL removes the existing Default Access Control List (ACL) of
// the specified directory.
//
// defaultACLFilePath is the Data Lake Store path (starting with '/') of the
// directory with the default ACL being removed. op is the constant value for
// the operation.
func (client Client) RemoveDefaultACL(defaultACLFilePath string, op string) (result autorest.Response, err error) {
	req, err := client.RemoveDefaultACLPreparer(defaultACLFilePath, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "RemoveDefaultACL", nil, "Failure preparing request")
	}

	resp, err := client.RemoveDefaultACLSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "RemoveDefaultACL", resp, "Failure sending request")
	}

	result, err = client.RemoveDefaultACLResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "RemoveDefaultACL", resp, "Failure responding to request")
	}

	return
}

// RemoveDefaultACLPreparer prepares the RemoveDefaultACL request.
func (client Client) RemoveDefaultACLPreparer(defaultACLFilePath string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"defaultAclFilePath": autorest.Encode("path", defaultACLFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{defaultAclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// RemoveDefaultACLSender sends the RemoveDefaultACL request. The method will close the
// http.Response Body if it receives an error.
func (client Client) RemoveDefaultACLSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// RemoveDefaultACLResponder handles the response to the RemoveDefaultACL request. The method always
// closes the http.Response Body.
func (client Client) RemoveDefaultACLResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// Rename rename a file or directory.
//
// renameFilePath is the Data Lake Store path (starting with '/') of the file
// or directory to move/rename. destination is the path to move/rename the
// file or folder to op is the constant value for the operation.
func (client Client) Rename(renameFilePath string, destination string, op string) (result FileOperationResult, err error) {
	req, err := client.RenamePreparer(renameFilePath, destination, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Rename", nil, "Failure preparing request")
	}

	resp, err := client.RenameSender(req)
	if err != nil {
		result.Response = autorest.Response{Response: resp}
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "Rename", resp, "Failure sending request")
	}

	result, err = client.RenameResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "Rename", resp, "Failure responding to request")
	}

	return
}

// RenamePreparer prepares the Rename request.
func (client Client) RenamePreparer(renameFilePath string, destination string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"renameFilePath": autorest.Encode("path", renameFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"destination": autorest.Encode("query", destination),
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{renameFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// RenameSender sends the Rename request. The method will close the
// http.Response Body if it receives an error.
func (client Client) RenameSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// RenameResponder handles the response to the Rename request. The method always
// closes the http.Response Body.
func (client Client) RenameResponder(resp *http.Response) (result FileOperationResult, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByUnmarshallingJSON(&result),
		autorest.ByClosing())
	result.Response = autorest.Response{Response: resp}
	return
}

// SetACL sets the Access Control List (ACL) for a file or folder.
//
// setACLFilePath is the Data Lake Store path (starting with '/') of the file
// or directory on which to set the ACL. aclspec is the ACL spec included in
// ACL creation operations in the format
// '[default:]user|group|other::r|-w|-x|-' op is the constant value for the
// operation.
func (client Client) SetACL(setACLFilePath string, aclspec string, op string) (result autorest.Response, err error) {
	req, err := client.SetACLPreparer(setACLFilePath, aclspec, op)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "SetACL", nil, "Failure preparing request")
	}

	resp, err := client.SetACLSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "SetACL", resp, "Failure sending request")
	}

	result, err = client.SetACLResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "SetACL", resp, "Failure responding to request")
	}

	return
}

// SetACLPreparer prepares the SetACL request.
func (client Client) SetACLPreparer(setACLFilePath string, aclspec string, op string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"setAclFilePath": autorest.Encode("path", setACLFilePath),
	}

	queryParameters := map[string]interface{}{
		"aclspec":     autorest.Encode("query", aclspec),
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{setAclFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetACLSender sends the SetACL request. The method will close the
// http.Response Body if it receives an error.
func (client Client) SetACLSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetACLResponder handles the response to the SetACL request. The method always
// closes the http.Response Body.
func (client Client) SetACLResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SetFileExpiry sets or removes the expiration time on the specified file.
// This operation can only be executed against files. Folders are not
// supported.
//
// filePath is the Data Lake Store path (starting with '/') of the file on
// which to set or remove the expiration time. expiryOption is indicates the
// type of expiration to use for the file: 1. NeverExpire: ExpireTime is
// ignored. 2. RelativeToNow: ExpireTime is an integer in milliseconds
// representing the expiration date relative to when file expiration is
// updated. 3. RelativeToCreationDate: ExpireTime is an integer in
// milliseconds representing the expiration date relative to file creation.
// 4. Absolute: ExpireTime is an integer in milliseconds, as a Unix timestamp
// relative to 1/1/1970 00:00:00. Possible values include: 'NeverExpire',
// 'RelativeToNow', 'RelativeToCreationDate', 'Absolute' op is the constant
// value for the operation. expireTime is the time that the file will expire,
// corresponding to the ExpiryOption that was set.
func (client Client) SetFileExpiry(filePath string, expiryOption ExpiryOptionType, op string, expireTime *int64) (result autorest.Response, err error) {
	req, err := client.SetFileExpiryPreparer(filePath, expiryOption, op, expireTime)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "SetFileExpiry", nil, "Failure preparing request")
	}

	resp, err := client.SetFileExpirySender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "SetFileExpiry", resp, "Failure sending request")
	}

	result, err = client.SetFileExpiryResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "SetFileExpiry", resp, "Failure responding to request")
	}

	return
}

// SetFileExpiryPreparer prepares the SetFileExpiry request.
func (client Client) SetFileExpiryPreparer(filePath string, expiryOption ExpiryOptionType, op string, expireTime *int64) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"filePath": autorest.Encode("path", filePath),
	}

	queryParameters := map[string]interface{}{
		"api-version":  client.APIVersion,
		"expiryOption": autorest.Encode("query", expiryOption),
		"op":           autorest.Encode("query", op),
	}
	if expireTime != nil {
		queryParameters["expireTime"] = autorest.Encode("query", *expireTime)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/WebHdfsExt/{filePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetFileExpirySender sends the SetFileExpiry request. The method will close the
// http.Response Body if it receives an error.
func (client Client) SetFileExpirySender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetFileExpiryResponder handles the response to the SetFileExpiry request. The method always
// closes the http.Response Body.
func (client Client) SetFileExpiryResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SetOwner sets the owner of a file or directory.
//
// setOwnerFilePath is the Data Lake Store path (starting with '/') of the
// file or directory for which to set the owner. op is the constant value for
// the operation. owner is the AAD Object ID of the user owner of the file or
// directory. If empty, the property will remain unchanged. group is the AAD
// Object ID of the group owner of the file or directory. If empty, the
// property will remain unchanged.
func (client Client) SetOwner(setOwnerFilePath string, op string, owner string, group string) (result autorest.Response, err error) {
	req, err := client.SetOwnerPreparer(setOwnerFilePath, op, owner, group)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "SetOwner", nil, "Failure preparing request")
	}

	resp, err := client.SetOwnerSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "SetOwner", resp, "Failure sending request")
	}

	result, err = client.SetOwnerResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "SetOwner", resp, "Failure responding to request")
	}

	return
}

// SetOwnerPreparer prepares the SetOwner request.
func (client Client) SetOwnerPreparer(setOwnerFilePath string, op string, owner string, group string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"setOwnerFilePath": autorest.Encode("path", setOwnerFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if len(owner) > 0 {
		queryParameters["owner"] = autorest.Encode("query", owner)
	}
	if len(group) > 0 {
		queryParameters["group"] = autorest.Encode("query", group)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{setOwnerFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetOwnerSender sends the SetOwner request. The method will close the
// http.Response Body if it receives an error.
func (client Client) SetOwnerSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetOwnerResponder handles the response to the SetOwner request. The method always
// closes the http.Response Body.
func (client Client) SetOwnerResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}

// SetPermission sets the permission of the file or folder.
//
// setPermissionFilePath is the Data Lake Store path (starting with '/') of
// the file or directory for which to set the permission. op is the constant
// value for the operation. permission is a string representation of the
// permission (i.e 'rwx'). If empty, this property remains unchanged.
func (client Client) SetPermission(setPermissionFilePath string, op string, permission string) (result autorest.Response, err error) {
	req, err := client.SetPermissionPreparer(setPermissionFilePath, op, permission)
	if err != nil {
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "SetPermission", nil, "Failure preparing request")
	}

	resp, err := client.SetPermissionSender(req)
	if err != nil {
		result.Response = resp
		return result, autorest.NewErrorWithError(err, "filesystem.Client", "SetPermission", resp, "Failure sending request")
	}

	result, err = client.SetPermissionResponder(resp)
	if err != nil {
		err = autorest.NewErrorWithError(err, "filesystem.Client", "SetPermission", resp, "Failure responding to request")
	}

	return
}

// SetPermissionPreparer prepares the SetPermission request.
func (client Client) SetPermissionPreparer(setPermissionFilePath string, op string, permission string) (*http.Request, error) {
	pathParameters := map[string]interface{}{
		"setPermissionFilePath": autorest.Encode("path", setPermissionFilePath),
	}

	queryParameters := map[string]interface{}{
		"api-version": client.APIVersion,
		"op":          autorest.Encode("query", op),
	}
	if len(permission) > 0 {
		queryParameters["permission"] = autorest.Encode("query", permission)
	}

	preparer := autorest.CreatePreparer(
		autorest.AsPut(),
		autorest.WithBaseURL(client.BaseURI),
		autorest.WithPathParameters("/webhdfs/v1/{setPermissionFilePath}", pathParameters),
		autorest.WithQueryParameters(queryParameters))
	return preparer.Prepare(&http.Request{})
}

// SetPermissionSender sends the SetPermission request. The method will close the
// http.Response Body if it receives an error.
func (client Client) SetPermissionSender(req *http.Request) (*http.Response, error) {
	return autorest.SendWithSender(client, req)
}

// SetPermissionResponder handles the response to the SetPermission request. The method always
// closes the http.Response Body.
func (client Client) SetPermissionResponder(resp *http.Response) (result autorest.Response, err error) {
	err = autorest.Respond(
		resp,
		client.ByInspecting(),
		azure.WithErrorUnlessStatusCode(http.StatusOK),
		autorest.ByClosing())
	result.Response = resp
	return
}
