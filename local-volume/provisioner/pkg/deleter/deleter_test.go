/*
Copyright 2017 The Kubernetes Authors.

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package deleter

import (
	"path/filepath"
	"testing"

	"github.com/kubernetes-incubator/external-storage/local-volume/provisioner/pkg/cache"
	"github.com/kubernetes-incubator/external-storage/local-volume/provisioner/pkg/common"
	"github.com/kubernetes-incubator/external-storage/local-volume/provisioner/pkg/util"

	"time"

	"k8s.io/api/core/v1"
	"k8s.io/client-go/tools/record"
)

const (
	testHostDir      = "/mnt/disks"
	testMountDir     = "/discoveryPath"
	testStorageClass = "sc1"
)

type testConfig struct {
	// Values defined by the test
	apiShouldFail       bool
	volDeleteShouldFail bool
	// Precreated PVs
	vols map[string]*testVol
	// Expected names of deleted PV
	expectedDeletedPVs map[string]string

	// ==== The remaining fields are set during setup ====
	// Map of PVs generated by setup for the test
	generatedPVs map[string]*v1.PersistentVolume
	// Layout of directory in which local volumes are searched for (optional, can be nil)
	searchDir map[string][]*util.FakeDirEntry
	volUtil   *util.FakeVolumeUtil
	apiUtil   *util.FakeAPIUtil
	cache     *cache.VolumeCache
	procTable *FakeProcTableImpl
}

type testVol struct {
	pvPhase    v1.PersistentVolumePhase
	VolumeMode string
}

func TestDeleteVolumes_Basic(t *testing.T) {
	vols := map[string]*testVol{
		"pv1": {
			pvPhase: v1.VolumePending,
		},
		"pv2": {
			pvPhase: v1.VolumeAvailable,
		},
		"pv3": {
			pvPhase: v1.VolumeBound,
		},
		"pv4": {
			pvPhase: v1.VolumeReleased,
		},
		"pv5": {
			pvPhase: v1.VolumeFailed,
		},
	}
	expectedDeletedPVs := map[string]string{"pv4": ""}
	test := &testConfig{
		vols:               vols,
		expectedDeletedPVs: expectedDeletedPVs,
	}
	d := testSetup(t, test, nil)

	d.DeletePVs()
	waitForAsyncToComplete(t, d)
	verifyDeletedPVs(t, test)
}

func TestDeleteVolumes_Twice(t *testing.T) {
	vols := map[string]*testVol{
		"pv4": {
			pvPhase: v1.VolumeReleased,
		},
	}
	expectedDeletedPVs := map[string]string{"pv4": ""}
	test := &testConfig{
		vols:               vols,
		expectedDeletedPVs: expectedDeletedPVs,
	}
	d := testSetup(t, test, nil)

	d.DeletePVs()
	waitForAsyncToComplete(t, d)
	verifyDeletedPVs(t, test)

	d.DeletePVs()
	waitForAsyncToComplete(t, d)
	test.expectedDeletedPVs = map[string]string{}
	verifyDeletedPVs(t, test)
}

func TestDeleteVolumes_Empty(t *testing.T) {
	vols := map[string]*testVol{}
	expectedDeletedPVs := map[string]string{}
	test := &testConfig{
		vols:               vols,
		expectedDeletedPVs: expectedDeletedPVs,
	}
	d := testSetup(t, test, nil)

	d.DeletePVs()
	waitForAsyncToComplete(t, d)
	verifyDeletedPVs(t, test)
}

func TestDeleteVolumes_DeletePVFails(t *testing.T) {
	vols := map[string]*testVol{
		"pv4": {
			pvPhase: v1.VolumeReleased,
		},
	}
	test := &testConfig{
		apiShouldFail:      true,
		vols:               vols,
		expectedDeletedPVs: map[string]string{},
	}
	d := testSetup(t, test, nil)

	d.DeletePVs()
	waitForAsyncToComplete(t, d)
	verifyDeletedPVs(t, test)
	verifyPVExists(t, test)
}

func TestDeleteVolumes_DeletePVNotFound(t *testing.T) {
	vols := map[string]*testVol{
		"pv4": {
			pvPhase: v1.VolumeReleased,
		},
	}
	test := &testConfig{
		apiShouldFail:      false,
		vols:               vols,
		expectedDeletedPVs: map[string]string{"pv4": ""},
	}
	d := testSetup(t, test, nil)

	d.DeletePVs()
	waitForAsyncToComplete(t, d)
	verifyDeletedPVs(t, test)

	// delete not found pv
	err := d.deletePV(test.generatedPVs["pv4"])
	if err != nil {
		t.Error(err)
	}
	waitForAsyncToComplete(t, d)

	recorderChan := d.RuntimeConfig.Recorder.(*record.FakeRecorder).Events
	select {
	case err := <-recorderChan:
		t.Errorf("error deletePV %v", err)
	default:
	}
}

func TestDeleteVolumes_CleanupFails(t *testing.T) {
	vols := map[string]*testVol{
		"pv4": {
			pvPhase: v1.VolumeReleased,
		},
	}
	test := &testConfig{
		volDeleteShouldFail: true,
		vols:                vols,
		expectedDeletedPVs:  map[string]string{},
	}
	d := testSetup(t, test, nil)

	d.DeletePVs()
	waitForAsyncToComplete(t, d)
	verifyDeletedPVs(t, test)
	verifyPVExists(t, test)
}

func TestDeleteBlock_BasicProcessExec(t *testing.T) {
	vols := map[string]*testVol{
		"pv4": {
			pvPhase:    v1.VolumeReleased,
			VolumeMode: util.FakeEntryBlock,
		},
	}
	// The volume should be deleted after a successful cleanup
	expectedDeletedPVs := map[string]string{"pv4": ""}
	test := &testConfig{vols: vols, expectedDeletedPVs: expectedDeletedPVs}
	d := testSetup(t, test, []string{"sh", "-c", "echo \"hello\""})

	err := d.deletePV(test.generatedPVs["pv4"])
	if err != nil {
		t.Error(err)
	}

	waitForAsyncToComplete(t, d)

	// A few checks to see if its still running.
	if test.procTable.IsRunningCount == 0 {
		t.Errorf("Unexpected isRunning count %d", test.procTable.IsRunningCount)
	}
	// Must have marked itself as running
	if test.procTable.MarkRunningCount != 1 {
		t.Errorf("Unexpected MarkRunning count %d", test.procTable.MarkRunningCount)
	}
	// Must have marked itself has done
	if test.procTable.MarkDoneCount != 1 {
		t.Errorf("Unexpected MarkDone count %d", test.procTable.MarkDoneCount)
	}

	verifyDeletedPVs(t, test)
}

func TestDeleteBlock_FailedProcess(t *testing.T) {
	vols := map[string]*testVol{
		"pv4": {
			pvPhase:    v1.VolumeReleased,
			VolumeMode: util.FakeEntryBlock,
		},
	}
	// Nothing should be deleted as it was a failed cleanup process
	expectedDeletedPVs := map[string]string{}

	test := &testConfig{vols: vols, expectedDeletedPVs: expectedDeletedPVs}
	d := testSetup(t, test, []string{"sh", "-c", "exit 10"})
	err := d.deletePV(test.generatedPVs["pv4"])
	if err != nil {
		t.Error(err)
	}

	waitForAsyncToComplete(t, d)

	// A few checks to see if its still running.
	if test.procTable.IsRunningCount == 0 {
		t.Errorf("Unexpected isRunning count %d", test.procTable.IsRunningCount)
	}
	// Must have marked itself as running
	if test.procTable.MarkRunningCount != 1 {
		t.Errorf("Unexpected MarkRunning count %d", test.procTable.MarkRunningCount)
	}
	// Must have marked itself has done
	if test.procTable.MarkDoneCount != 1 {
		t.Errorf("Unexpected MarkDone count %d", test.procTable.MarkDoneCount)
	}

	verifyDeletedPVs(t, test)

}

func TestDeleteBlock_DuplicateAttempts(t *testing.T) {
	vols := map[string]*testVol{
		"pv4": {
			pvPhase:    v1.VolumeReleased,
			VolumeMode: util.FakeEntryBlock,
		},
	}
	expectedDeletedPVs := map[string]string{"pv4": ""}
	test := &testConfig{vols: vols, expectedDeletedPVs: expectedDeletedPVs}

	d := testSetup(t, test, []string{"sh", "-c", "echo \"hello\""})

	// Simulate a currently running process by marking it as running in process table
	test.procTable.MarkRunning("pv4")

	err := d.deletePV(test.generatedPVs["pv4"])
	if err != nil {
		t.Error(err)
	}

	// The second execution must have checked to see if something is already running.
	if test.procTable.IsRunningCount != 1 {
		t.Errorf("Unexpected isrrunning %d", test.procTable.IsRunningCount)
	}

	// The second process should not have attempted to mark itself running.
	if test.procTable.MarkRunningCount != 1 {
		t.Errorf("Unexpected MarkRunning %d", test.procTable.MarkRunningCount)
	}

	// Nothing should have marked itself as done, since the first run was a fake and second run did not happen
	if test.procTable.MarkDoneCount != 0 {
		t.Errorf("Unexpected MarkDone %d", test.procTable.MarkDoneCount)
	}
}

func testSetup(t *testing.T, config *testConfig, cleanupCmd []string) *Deleter {
	config.cache = cache.NewVolumeCache()
	config.apiUtil = util.NewFakeAPIUtil(false, config.cache)
	config.procTable = NewFakeProcTable()
	config.volUtil = util.NewFakeVolumeUtil(config.volDeleteShouldFail, map[string][]*util.FakeDirEntry{})

	// Precreate PVs
	config.generatedPVs = map[string]*v1.PersistentVolume{}
	newVols := map[string][]*util.FakeDirEntry{}
	newVols["test1"] = []*util.FakeDirEntry{}
	for pvName, vol := range config.vols {
		fakePath := filepath.Join(testHostDir, "test1", "entry-"+pvName)
		lpvConfig := common.LocalPVConfig{
			Name:         pvName,
			HostPath:     fakePath,
			StorageClass: testStorageClass,
		}
		// If volume mode has been explicitly specified in the volume config, then explicitly set it in the PV.
		switch vol.VolumeMode {
		case util.FakeEntryBlock:
			lpvConfig.VolumeMode = v1.PersistentVolumeBlock
		case util.FakeEntryFile:
			lpvConfig.VolumeMode = v1.PersistentVolumeFilesystem
		}
		pv := common.CreateLocalPVSpec(&lpvConfig)
		pv.Status.Phase = vol.pvPhase

		_, err := config.apiUtil.CreatePV(pv)
		if err != nil {
			t.Fatalf("Error creating fake PV: %v", err)
		}
		// Add PV to cache
		config.cache.AddPV(pv)
		// Track it in the list of generated PVs
		config.generatedPVs[pvName] = pv
		// Make sure the fake Volumeutil knows about it
		newVols["test1"] = append(newVols["test1"], &util.FakeDirEntry{Name: "entry-" + pvName, Hash: 0xf34b8003,
			VolumeType: vol.VolumeMode})
	}
	// Update volume util
	config.volUtil.AddNewDirEntries(testMountDir, newVols)

	config.apiUtil = util.NewFakeAPIUtil(config.apiShouldFail, config.cache)

	userConfig := &common.UserConfig{
		DiscoveryMap: map[string]common.MountConfig{
			testStorageClass: {
				HostDir:             testHostDir,
				MountDir:            testMountDir,
				BlockCleanerCommand: cleanupCmd,
			},
		},
	}

	// set buffer size big enough, not all cases care about recorder.
	fakeRecorder := record.NewFakeRecorder(100)
	runtimeConfig := &common.RuntimeConfig{
		UserConfig: userConfig,
		Cache:      config.cache,
		VolUtil:    config.volUtil,
		APIUtil:    config.apiUtil,
		Recorder:   fakeRecorder,
	}

	return NewDeleter(runtimeConfig, config.procTable)
}

func verifyDeletedPVs(t *testing.T, config *testConfig) {
	deletedPVs := config.apiUtil.GetAndResetDeletedPVs()
	expectedLen := len(config.expectedDeletedPVs)
	actualLen := len(deletedPVs)
	if expectedLen != actualLen {
		t.Errorf("Expected %d deleted PVs, got %d", expectedLen, actualLen)
	}

	for pvName := range deletedPVs {
		_, found := config.expectedDeletedPVs[pvName]
		if !found {
			t.Errorf("Did not expect deleted PVs %q", pvName)
			continue
		}
		_, found = config.cache.GetPV(pvName)
		if found {
			t.Errorf("PV %q still exists in cache", pvName)
		}
	}
}

func verifyPVExists(t *testing.T, config *testConfig) {
	for pvName := range config.vols {
		_, found := config.cache.GetPV(pvName)
		if !found {
			t.Errorf("PV %q doesn't exist in cache", pvName)
		}
	}
}

// waitForAsyncToComplete Since commands are all async, this function helps wait for commands to complete.
func waitForAsyncToComplete(t *testing.T, d *Deleter) {
	for count := 0; count < 30 && !d.ProcTable.IsEmpty(); count++ {
		time.Sleep(200 * time.Millisecond)
	}

	if !d.ProcTable.IsEmpty() {
		t.Errorf("Command failed to complete")
	}
}
